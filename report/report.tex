\documentclass[a4paper]{article}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\newcommand{\documentTitle}{PJAVA Compiler} %Macro definition
\newcommand{\documentAuthors}{João Rafael (2008111876, jprafael@student.dei.uc.pt) \and José Ribeiro (2008112181, jbaia@student.dei.uc.pt)} %Macro definition

\title{\documentTitle}
\author{\documentAuthors{}}

\usepackage{hyperref}
\hypersetup{
	pdftitle = \documentTitle
	,pdfauthor = \documentAuthors
	,pdfsubject = {Project Report}
	,pdfkeywords = {PJAVA Compiler} {Compilers} {Syntax Analysis} {Semantic Analysis} {Code Generation}
	,pdfborder = {0 0 0}
}

\usepackage{alltt}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{array}
\usepackage{anysize}
\usepackage{lscape}
\usepackage[pdftex]{graphicx}
\usepackage{longtable}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{minted}

\marginsize{3.5cm}{3.5cm}{3cm}{3cm}

\makeatletter

\begin{document}

\renewcommand{\figurename}{Figure}
\renewcommand{\contentsname}{Contents}

\maketitle
\cleardoublepage

\tableofcontents
\cleardoublepage

\setlength{\parindent}{1cm}
\setlength{\parskip}{0.3cm}

\section{Introduction}
\indent \indent ...

\cleardoublepage

\section{Syntatic Analysis}
\indent \indent Tal como indicado no enunciado do projecto, na linguagem PJAVA apenas se pretende explorar a vertente procedimental do JAVA. 
Deste modo, decidimos que implementar \texttt{packages} seria desnecessário.

\indent Devido a esta escolha, os métodos \texttt{System.out.println()} e \texttt{System.in.nextInt()} (aqui considerado equivalente a \texttt{Scanner.nextInt()})
são implementados como funções \emph{built-in}. Estes serão posteriormente distinguidos na semântica.

Outras funcionalidades da linguagem que necessitem implicitamente ou explicitamente de um objecto também não foram implementadas (\texttt{try-catch-finally}, \texttt{syncronized}, \\ \texttt{instanceof}, entre outros).

Ainda que sejam permitidas definições compostas de \texttt{arrays}\footnote[1]{Ex.: \texttt{<type>[ ] <id>[ ]}.}, estas não são permitidas enquanto parâmetros de funções.

Todas as restantes funcionalidades estão implementadas de acordo com a especificação.

% TODO: error handling
\cleardoublepage

\subsection{Grammar Specification}
\begin{minted}[mathescape]{antlr}

application
	: class_def END
	| error	END
	;

array_decl
	: type_object dims_empty_list
	;

assign_op
	: var '=' expr
	| var SHIFT_R_ASSIGN expr
	| var SHIFT_L_ASSIGN expr
	| var ADD_ASSIGN expr
	| var SUB_ASSIGN expr
	| var MUL_ASSIGN expr
	| var DIV_ASSIGN expr
	| var MOD_ASSIGN expr
	| var AND_ASSIGN expr
	| var XOR_ASSIGN expr
	| var OR_ASSIGN expr
	;

binary_op
	: expr '+' expr
	| expr '-' expr
	| expr '*' expr
	| expr '/' expr
	| expr '%' expr

	| expr '&' expr
	| expr '|' expr
	| expr '^' expr
	| expr SHIFT_R expr
	| expr SHIFT_L expr
	
	| expr AND_OP expr
	| expr OR_OP expr

	| expr EQ_OP expr
	| expr NE_OP expr
	| expr '<' expr
	| expr '>' expr
	| expr LE_OP expr
	| expr GE_OP expr
	| expr EQ3_OP expr
	| expr NE3_OP expr
	| assign_op
	;

break
	: BREAK ';'
	| BREAK ID ';'
	;

class_def
	: CLASS ID '{' '}'
	| CLASS ID '{' class_stmt_list '}'
	| class_stmt_privacy CLASS ID '{' '}'
	| class_stmt_privacy CLASS ID '{' class_stmt_list '}'
	;

class_stmt
	: member_stmt
	| class_stmt_privacy member_stmt
	| class_stmt_scope member_stmt
	| class_stmt_privacy class_stmt_scope member_stmt
	;

class_stmt_privacy
	: PUBLIC
	| PRIVATE
	;

class_stmt_scope
	: FINAL
	| STATIC
	| STATIC FINAL
	| FINAL STATIC
	;

class_stmt_list
	: class_stmt
	| class_stmt class_stmt_list
	;

continue
	: CONTINUE ';'
	| CONTINUE ID ';'
	;

dims
	: dims_sized_list
	| dims_sized_list dims_empty_list
	;

\end{minted}
\cleardoublepage
\begin{minted}[mathescape]{antlr}

dims_empty
	: '[' ']'
	;

dims_empty_list
	: dims_empty
	| dims_empty_list dims_empty
	;

dims_sized
	: '[' expr ']'
	;

dims_sized_list
	: dims_sized
	| dims_sized_list dims_sized
	; 

do_while
	: DO stmt WHILE '(' expr ')' ';'
	;

expr
	: var %prec LOW_PREC
	| new_op %prec LOW_PREC
	| '(' expr ')'
	| '(' type_decl ')' expr
	| CONSTANT
	| func_call
	| expr_op
	| error
	;

expr_list
	: expr
	| expr ',' expr_list
	;

expr_op
	: unary_op
	| binary_op
	| ternary_op
	;
for
	: FOR '(' for_init ';' for_cond ';' for_inc ')' stmt
	;

\end{minted}
\cleardoublepage
\begin{minted}[mathescape]{antlr}

for_cond
	: /* empty */
	| expr
	;

for_expr
	: incr_op
	| assign_op
	| func_call
	;

for_expr_list
	: for_expr
	| for_expr ',' for_expr_list
	;

for_init
	: /* empty */
	| var_defs
	| for_expr_list
	;

for_inc
	: /* empty */
	| for_expr_list
	;
 	
func_call
	: ID func_call_arg_list
	;

func_call_arg_list
	: '(' ')'
	| '(' expr_list ')'
	;

func_def
	: type_decl ID func_def_args '{' '}'
	| type_decl ID func_def_args '{' stmt_list '}'
	;

func_def_arg
	: type_decl ID
	;

func_def_arg_list
	: func_def_arg
	| func_def_arg ',' func_def_arg_list
	;

func_def_args
	: '(' ')'
	| '(' func_def_arg_list ')'
	;

if
	: IF '(' expr ')' stmt %prec LOW_PREC
	| IF '(' expr ')' stmt ELSE stmt
	;

incr_op
	: INC_OP var
	| var INC_OP
	| DEC_OP var
	| var DEC_OP
	;

loop_stmt
	: for
	| ID ':' for
	| while
	| ID ':' while
	| do_while
	| ID ':' do_while
	;

member_stmt
	: ';'
	| var_stmt
	| func_def
	;

new_op
	: NEW type_object dims
	;

return
	: RETURN ';'
	| RETURN expr ';'
	;

\end{minted}
\cleardoublepage
\begin{minted}[mathescape]{antlr}

stmt
	: ';'
	| '{' '}'
	| '{' stmt_list '}'
	| var_stmt
	| assign_op ';'
	| incr_op ';'
	| if
	| loop_stmt
	| func_call ';'
	| switch
	| break
	| continue
	| return
	| error
	;

stmt_list
	: stmt
	| stmt stmt_list
	;

switch
	: SWITCH '(' expr ')' '{' '}'
	| SWITCH '(' expr ')' '{' switch_stmt_list '}'
	| ID ':' SWITCH '(' expr ')' '{' '}'
	| ID ':' SWITCH '(' expr ')' '{' switch_stmt_list '}'
	;

switch_stmt
	: DEFAULT ':'
	| DEFAULT ':' stmt_list
	| CASE CONSTANT ':'
	| CASE CONSTANT ':' stmt_list
	;

switch_stmt_list
	: switch_stmt
	| switch_stmt switch_stmt_list
	;

ternary_op
	: expr '?' expr ':' expr
	;

type_decl
	: type_object
	| array_decl
	;

type_native
	: BOOL
	| BYTE
	| CHAR
	| DOUBLE
	| FLOAT
	| INT
	| LONG
	| SHORT
	| STRING
	| VOID
	;

type_object
	: type_native
	;

unary_op
	: incr_op
	| '+' expr
	| '-' expr
	| '!' expr
	| '~' expr
	;

var
	: ID %prec LOW_PREC
	| '(' var ')'
	| '(' new_op ')'
	| var dims_sized
	| func_call dims_sized
	;

var_def
	: var_def_left
	| var_def_left '=' var_initializer
	;

var_def_list
	: var_def
	| var_def ',' var_def_list
	;

var_def_left
	: ID
	| ID dims_empty_list
	;

\end{minted}
\cleardoublepage
\begin{minted}[mathescape]{antlr}

var_defs
	: type_decl var_def_list
	;

var_initializer
	: '{' '}'
	| '{' var_initializer_list '}'
	| '{' var_initializer_list ',' '}'
	| expr
	;

var_initializer_list
	: var_initializer
	| var_initializer_list ',' var_initializer
 	;

var_stmt															
	: var_defs ';'
	;

while
	: WHILE '(' expr ')' stmt
	;

\end{minted}

\cleardoublepage

\subsection{Abstract Syntax}
\indent \indent A partir da definição da gramática é possível extrair a sintaxe abstracta, subdividindo cada disjunção de regras numa disjunção de predicados.
Aos nomes das regras acrescentamos o prefixo "is\_" ao seu predicado correspondente;
dessa mesma forma, acrescentamos o sufixo "\_list" às regras que constituem listas de elementos.
A disjunção dessas regras (no YACC representada pelo símbolo |) é transformada na disjunção de predicados utilizando para isso
o símbolo de disjunção lógico $\vee$.

\indent Por exemplo, na regra
\begin{minted}[mathescape]{antlr}
type_decl
	: type_object
	| array_decl
	;
\end{minted}

o seu correspondente na sintaxe abstracta é \\ \\
is\_type\_decl $\to$ <is\_type\_object : type\_object> $\vee$ <is\_array\_decl : array> \\

\indent \indent Apesar de aparecerem referidos na definição da sintaxe abstracta, is\_ID, \\
is\_CONSTANT e outros tipos (identificados com a mesma nomenclatura),
não são expressos segundo uma regra pois são tokens obtidos a partir da análise lexical do programa fonte.

Segue-se a especificação da sintaxe abstracta.

\cleardoublepage

\subsubsection{Abstract Syntax Specification}
\begin{longtable}{lcl}
%%% TODO Transformar regras do pjava.y em disjunções (ignorando listas e considerando enums)
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO
%%% TODO

	is\_application				& $\to$ & <is\_class\_def : class> \\
	is\_array\_decl 			& $\to$ & <is\_type\_object : type> <is\_dims\_empty\_list : empty> \\
	is\_assign\_op				& $\to$ & <is\_var : var> <is\_type\_assign\_op : op> <is\_expr : expr> \\
	is\_type\_assign\_op		& $\to$ & <is\_EQUAL> \\
								& $\vee$ & <is\_SHIFT\_R\_ASSIGN> \\
								& $\vee$ & <is\_SHIFT\_L\_ASSIGN> \\
								& $\vee$ & <is\_ADD\_ASSIGN> \\
								& $\vee$ & <is\_SUB\_ASSIGM> \\
								& $\vee$ & <is\_MUL\_ASSIGN> \\
								& $\vee$ & <is\_DIV\_ASSIGN> \\
								& $\vee$ & <is\_MOD\_ASSIGN> \\
								& $\vee$ & <is\_AND\_ASSIGN> \\
								& $\vee$ & <is\_XOR\_ASSIGN> \\
								& $\vee$ & <is\_OR\_ASSIGN> \\
								...TODO & $\lambda$ & ...TODO
\end{longtable}

\subsection{Abstract Syntax Tree Implementation}
A implementação das estruturas da árvore de sintaxe abstracta foi feita segundo as seguintes regras:
\begin{itemize}
	\item Cada conjunção de predicados é colocada numa \texttt{struct};
	\item Cada disjunção, de ou predicados ou conjunções de predicados, é colocada numa \texttt{union},
		utilizando um \texttt{enum} auxiliar de identificação do campo da \texttt{union} utilizado
		(nalguns casos determinando implicitamente o valor de um campo);
	\item Todas os predicados que seleccionam apenas objectos elementares são \texttt{typedef}'d para o seu objecto elementar correspondente,
		dado que estas regras foram mantidas com o objectivo de facilitar futuras extensões sintácticas da linguagem.
\end{itemize}

A regra is\_empty\_dims é omitida da AS uma vez que a informação semântica que esta indica não depende do seu conteúdo, mas sim da sua existência.
Assim, na implementação de is\_empty\_dims\_list é apenas necessário guardar um inteiro, correspondente ao número de vezes que a regra é repetida.

\subsection{Syntatic Choices}
\indent \indent ...

\cleardoublepage

\section{Semantic Analysis}
\subsection{...}
\indent \indent ...
% TODO 2 passage
% Symbol table com stack de árvores AVL
% pesquisa sub linear

\subsection{Semantic Choices}
\indent \indent Decidimos considerar como \textbf{semanticamente válidas} as seguintes situações (algumas diferentes/restritivas relativamente à definição semântica do Java):
\begin{itemize}
	\item Declarações de variáveis em ciclos \texttt{single statement};
	\item Operadores de comparação (\texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}) em \texttt{strings}.
\end{itemize}

Da mesma forma, considerámos como \textbf{semanticamente inválidas} as seguintes situações:
\begin{itemize}
	\item \textit{Function overloading} \footnote[1]{Como consequência da ausência de \textit{function overloading} surge a necessidade de concatenar
		uma string (mesmo que vazia) com qualquer outro tipo de dados, para que estes sejam impressos por \texttt{System.out.println()}};
	\item Funções de argumentos variáveis (\texttt{...});
	\item Operadores \% and \%= envolvendo tipos de vírgula flutoante (dado que C não os permite, ao contrário de Java).
\end{itemize}

\cleardoublepage

\section{Code Generation}
\subsection{...}
\indent \indent ...

\subsection{Implementation Choices}
\indent \indent ...

\cleardoublepage
\section{Feature List}
\begin{itemize}
	\item Suporte aos tipos nativos:
	\begin{itemize}
		\item \texttt{void};
		\item \texttt{byte};
		\item \texttt{char};
		\item \texttt{short};
		\item \texttt{int};
		\item \texttt{long};
		\item \texttt{float};
		\item \texttt{double};
	\end{itemize}
	\item Suporte para o tipo \texttt{String};% TODO ref para a secção de semântica
	\item \texttt{Arrays} multi-dimensionais:
	\begin{itemize}
		\item Operação \texttt{new}: \quad \texttt{int a[] = new [10];}
		\item \texttt{Array initializers}: \quad \texttt{int a[][] = \{\{1,2\}, \{3,4,5\}\}; }
	\end{itemize}
	\item Definição de multiplas variáveis: \quad \texttt{int a = 1, b[] = \{1,2\}; }
	\item Operações com parâmetros de tipos distintos \footnote[1]{\texttt{long a = 1; a *= 3.5;}}.
	\item \texttt{Widening} e \texttt{Narrowing conversions};
	\item \texttt{Type-casting} de variáveis;
	\item Suporte aos operadores:
	\begin{itemize}
		\item Unários: \quad \verb|+ - ! ~ ++ --|
		\item Binários:
		\begin{itemize}
			\item Aritméticos: \quad \verb!+ - * / % & | ^ << >>!
			\item Relacionais: \quad \verb|== != < > <= >=|
			\item Booleanos: \quad \verb!&& ||!
			\item Atribuição: \quad \verb!= <<= >>= += -= *= /= %= &= ^= |=!
		\end{itemize}
		\item Ternário: \quad \texttt{ ? : } 
	\end{itemize}
	\item Suporte para as instruções:
	\begin{itemize}
		\item Ciclos: \quad \texttt{for while do..while}
		\item Controlo: \quad \texttt{if..else switch}
		\item Fluxo: \quad \texttt{break continue return}
	\end{itemize}
	\item Acesso aos argumentos de chamada;
	\item Instruções de ciclo, \texttt{switch}, \texttt{break}, \texttt{continue} com \texttt{labels} opcionais;
	\item Distinção entre variáveis globais e locais;
	\item Redefinição de variáveis globais \footnote[2]{As globais tornam-se inacessíveis no escopo onde a local está definida.}; 
	\item Definição de escopo ao nível do bloco \footnote[3]{As definições de variáveis efectuadas dentro de ciclos não propagam para fora deste.}; 
	\item Funções de entrada e saída:
	\begin{itemize}
		\item \texttt{System.out.println();}
		\item \texttt{System.in.nextInt();}
	\end{itemize}
	\item Chamadas a funções incluindo recursividade directa e indirecta;
	\item Variáveis, funções, ciclos e \texttt{switch} com o mesmo \texttt{id}/\texttt{label};
\end{itemize}

\end{document}
