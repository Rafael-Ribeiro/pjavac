\documentclass[a4paper]{article}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\newcommand{\documentTitle}{PJAVA Compiler} %Macro definition
\newcommand{\documentAuthors}{João Rafael (2008111876, jprafael@student.dei.uc.pt) \and José Ribeiro (2008112181, jbaia@student.dei.uc.pt)} %Macro definition

\title{\documentTitle}
\author{\documentAuthors{}}

\usepackage{hyperref}
\hypersetup{
	pdftitle = \documentTitle
	,pdfauthor = \documentAuthors
	,pdfsubject = {Project \#1 Report}
	,pdfkeywords = {PJAVA Compiler}
	,pdfborder = {0 0 0}
}

\usepackage{verbatim} 
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{array}
\usepackage{anysize}
\usepackage{lscape}
\usepackage[pdftex]{graphicx}

\marginsize{3.5cm}{3.5cm}{3cm}{3cm}

\makeatletter

\begin{document}
\renewcommand{\figurename}{Figure}
\maketitle
\cleardoublepage

\tableofcontents
\cleardoublepage

\setlength{\parindent}{1cm}
\setlength{\parskip}{0.3cm}

\section{Introduction}
\section{Abstract Syntax}
\indent \indent Apesar de aparecerem nomeados na definição da sintaxe abstracta, 
is\_ID, is\_CONSTANT e outros tipos (identificados com a mesma nomenclatura),
não são expressos segundo uma regra pois são tokens obtidos apartir da análise lexical do programa fonte.
De forma análoga, a regra is\_empty\_dims é omitida da AS uma vez que a informação semântica que esta indica não depende do seu conteúdo.

Uma vez que a linguagem a implementar é procedimental, decidimos implementar o método \texttt{System.out.println()} como uma função normal.
Neste caso a regra is_func_call não contém is_ID. 

%TODO aliases
\begin{tabular}{ll}
	is\_array\_decl 			& $\to$ <is\_type\_object: type> <is\_dims\_empty\_list: empty> \\
	is\_assign\_op				& $\to$ <is\_var: var> <is\_assign\_operator: op> <is\_expr: expr> \\
	is\_type\_assign\_op		& $\to$ is\_EQUAL \\
								& $\vee$ is\_SHIFT\_R\_ASSIGN \\
								& $\vee$ is\_SHIFT\_L\_ASSIGN \\
								& $\vee$ is\_ADD\_ASSIGN \\
								& $\vee$ is\_SUB\_ASSIGM \\
								& $\vee$ is\_MUL\_ASSIGN \\
								& $\vee$ is\_DIV\_ASSIGN \\
								& $\vee$ is\_MOD\_ASSIGN \\
								& $\vee$ is\_AND\_ASSIGN \\
								& $\vee$ is\_XOR\_ASSIGN \\
								& $\vee$ is\_OR\_ASSIGN \\
	is\_binary\_op				& $\to$ <is\_assign\_op: assign> $\vee$ (<is\_expr: left> <is\_expr: right) \\
	is\_break 					& $\to$ $\emptyset$ $\vee$ <is\_id: label> \\
	is\_class\_def				& $\to$ <is\_id: id> <is\_class\_stmt\_list: body> \\
	is\_class\_stmt\_privacy	& $\to$ is\_PRIVATE $\vee$ is\_PUBLIC\\	
	is\_class\_stmt\_scope		& $\to$ ($\emptyset$ $\vee$ is\_FINAL) ($\emptyset$ $\vee$ is\_STATIC) \\
	is\_class\_stmt 			& $\to$ <is\_class\_stmt\_scope: scope> <is\_member\_stmt: stmt> \\
	is\_continue				& $\to$ $\emptyset$ $\vee$ <is\_id: label> \\
	is\_dims					& $\to$ <is\_dims\_sized\_list: sized> (<is\_dims\_empty\_list: empty> $\vee$ $\emptyset$) \\
	is\_dims\_sized				& $\to$ <is\_expr: expr> \\
	is\_do\_while				& $\to$ <is\_stmt: body> <is\_expr: cond> \\
	is\_expr					& $\to$ <is\_var: var> \\
								& $\vee$ <is\_new\_op: new\_op> \\
								& $\vee$ <is\_type\_decl: type> <is\_expr: expr>\\
								& $\vee$ <is\_CONSTANT: constant> \\
								& $\vee$ <is\_func\_call: func\_call> \\
								& $\vee$ <is\_expr\_op: operation> \\

	is\_expr\_op				& $\to$ <is\_unary\_op: unary> \\
								& \;$\vee$ <is\_binary\_op: binary>\\
								& $\vee$ <is\_binary\_op: ternary>\\

\begin{comment}

expr_op
	: unary_op														{ $$ = insert_expr_op_unary($1); }
	| binary_op														{ $$ = insert_expr_op_binary($1); }
	| ternary_op													{ $$ = insert_expr_op_ternary($1); }
	;
\end{comment}

%==================================================== SEPARATOR ====================================================

\begin{comment}



\end{comment}

	& \\
	& \\ %visual separator
	& \\

	\begin{comment}
		- see is_stmt (repeated stmt_list)
	\end{comment}
	is\_loop\_stmt							& $\to$ ($\emptyset$ $\vee$ <is\_id : loop\_label>) (<is\_for : for\_stmt> $\vee$ <is\_while : while\_stmt> \\ 
											& $\vee$ <is\_do\_while : do\_while\_stmt>) \\
	is\_member\_stmt						& $\to$ <is\_var\_stmt : var> $\vee$ <is\_func\_def : func\_def> \\
	is\_new\_op								& $\to$ <is\_type\_object : type\_object> <is\_dims : dims> \\
	is\_return								& $\to$ $\emptyset$ $\vee$ <is\_expr : value> \\
	is\_stmt								& $\to$ <is\_stmt\_list : stmt\_list> \\
											& $\vee$ <is\_var\_stmt : var> \\
											& $\vee$ <is\_assign\_op : assign> \\
											& $\vee$ <is\_incr\_op : incr> \\
											& $\vee$ <is\_if : if\_stmt> \\
											& $\vee$ <is\_loop\_stmt : loop> \\
											& $\vee$ <is\_func\_call : func\_call> \\
											& $\vee$ <is\_switch : switch\_stmt> \\
											& $\vee$ <is\_break : break\_stmt> \\
											& $\vee$ <is\_continue : continue\_stmt> \\
											& $\vee$ <is\_return : return\_stmt> \\
	is\_switch								& $\to$ <is\_expr : expr> <is\_switch\_stmt\_list : list> \\
	is\_switch\_stmt						& $\to$ <is\_stmt\_list : list> ($\emptyset$ $\vee$ <is\_constant : constant> \\
	is\_ternary\_op							& $\to$ <is\_expr : if\_expr> <is\_expr : then\_expr> <is\_expr : else\_expr> \\
	is\_type\_decl							& $\to$ <is\_type\_object : type\_object> $\vee$ <is\_array\_decl : array> \\
	is\_type\_native						& $\to$ <is\_BOOL> \\
											& $\vee$ <is\_BYTE> \\
											& $\vee$ <is\_CHAR> \\
											& $\vee$ <is\_DOUBLE> \\
											& $\vee$ <is\_FLOAT> \\
											& $\vee$ <is\_INT> \\
											& $\vee$ <is\_LONG> \\
											& $\vee$ <is\_SHORT> \\
											& $\vee$ <is\_STRING> \\
											& $\vee$ <is\_VOID> \\
	is\_type\_object		 				& $\to$ <is\_type\_native: type> \\
	is\_unary\_op			 				& $\to$ <is\_incr\_op: incr> $\vee$ (<is\_unary\_op\_operator: op> <is\_expr: expr>) \\
	is\_unary\_op\_operator					& $\to$ is\_PLUS \\
											& $\vee$ is\_MINUS \\
											& $\vee$ is\_NOT \\
											& $\vee$ is\_BIN\_NOT \\
	is\_var					 				& $\to$ <is\_id: id> \\
											& $\vee$ <is\_new\_op: new\_op> \\
											& $\vee$ (<is\_var : var> <is\_dims\_sized : dims>) \\
											& $\vee$ (<is\_func\_call : func\_call> <is\_dims\_sized : dims>) \\
	is\_var\_def			 				& $\to$ <is\_var\_def\_left: left> ($\emptyset$ $\vee$ <is\_var\_initializer : var\_init>) \\
	is\_var\_def\_left		 				& $\to$ <is\_id: id> (<is\_dims : dims> $\vee$ is\_dims\_empty\_list : empty) \\
	is\_var\_defs		 					& $\to$ <is\_type\_decl: type> <is\_var\_def\_list : list> \\
	is\_var\_initializer 					& $\to$ <is\_var\_initializer\_list: array> $\vee$ <is\_expr : expr> \\
	is\_while 								& $\to$ <is\_expr : cond> <is\_stmt : body> \\
\end{tabular}

\end{document}
